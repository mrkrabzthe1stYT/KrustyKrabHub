local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
    Name = "KrustyKrabHub",
    Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
    LoadingTitle = "Best Hub Under The Sea",
    LoadingSubtitle = "By MrKrabzz",
    Theme = "Ocean", -- Check https://docs.sirius.menu/rayfield/configuration/themes
 
    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface
 
    ConfigurationSaving = {
       Enabled = True,
       FolderName = nil, -- Create a custom folder for your hub/game
       FileName = "Big Hub"
    },
 
    Discord = {
       Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
       Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
 
    KeySystem = false, -- Set this to true to use our key system
    KeySettings = {
       Title = "Untitled",
       Subtitle = "Key System",
       Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
 })
 
 -- MAIN TAB --
 local MainTab = Window:CreateTab("Main", nil) -- Title, Image

 local ESPEnabled = false
 local ESPTracerEnabled = false  -- This is the tracer toggle
 local HighlightedParts = {}
 local Tracers = {}
 local Player = game.Players.LocalPlayer
 local Teams = game:GetService("Teams")
 local CurrentESPColor = Color3.fromRGB(139, 0, 0) -- Default dark red

-- Helper function to create an outline box (using BillboardGui for visibility through walls)
local function CreateOutline(player)
    local character = player.Character
    if character and character:FindFirstChild("UpperTorso") then
        local upperTorso = character:FindFirstChild("UpperTorso")

        local function createBillboard(size, parent)
            local billboardGui = Instance.new("BillboardGui")
            billboardGui.Adornee = parent
            billboardGui.Parent = parent
            billboardGui.Size = UDim2.new(0, size.X, 0, size.Y)
            billboardGui.StudsOffset = Vector3.new(0, 0, 0)
            billboardGui.AlwaysOnTop = true
            billboardGui.MaxDistance = 1000
            billboardGui.Enabled = ESPEnabled

            local frame = Instance.new("Frame")
            frame.Parent = billboardGui
            frame.Size = UDim2.new(0, size.X, 0, size.Y)
            frame.BackgroundColor3 = CurrentESPColor -- Use the current ESP color
            frame.BackgroundTransparency = 0.4
            frame.BorderSizePixel = 2
            frame.BorderColor3 = CurrentESPColor -- Use the current ESP color

            return billboardGui
        end

        local torsoBox = createBillboard(Vector2.new(20, 20), upperTorso)
        HighlightedParts[player] = {torsoBox}

        game:GetService("RunService").Heartbeat:Connect(function()
            if character and character.Parent then
                if upperTorso and upperTorso.Parent then
                    torsoBox.StudsOffset = Vector3.new(0, 0, 0)
                end
            end
        end)
    end
end

-- Remove ESP highlight
local function UnhighlightPlayer(player)
    if HighlightedParts[player] then
        for _, billboardGui in ipairs(HighlightedParts[player]) do
            billboardGui.Parent = nil
        end
        HighlightedParts[player] = nil
    end
end

-- Create the tracer line from your character to the highlighted player
local function CreateTracer(player)
    local character = player.Character
    if character and character:FindFirstChild("UpperTorso") then
        local upperTorso = character:FindFirstChild("UpperTorso")
        local myCharacter = Player.Character
        if myCharacter and myCharacter:FindFirstChild("UpperTorso") then
            local myUpperTorso = myCharacter:FindFirstChild("UpperTorso")

            local line = Instance.new("Part")
            line.Size = Vector3.new(0.2, 0.2, 0.2)
            line.Anchored = true
            line.CanCollide = false
            line.Color = Color3.fromRGB(255, 0, 0) -- Red color for the line (can be customized)
            line.Parent = game.Workspace

            Tracers[player] = line

            game:GetService("RunService").Heartbeat:Connect(function()
                if myCharacter and myCharacter.Parent and upperTorso and upperTorso.Parent then
                    local startPosition = myUpperTorso.Position + Vector3.new(0, 1.5, 0)
                    local endPosition = upperTorso.Position + Vector3.new(0, 2, 0)
                    local direction = (endPosition - startPosition).unit
                    local distance = (endPosition - startPosition).Magnitude
                    line.CFrame = CFrame.new(startPosition, endPosition)
                    line.Size = Vector3.new(0.2, 0.2, distance)

                    if distance <= 0.2 then
                        line.Size = Vector3.new(0.2, 0.2, 0.2)
                    end
                end
            end)
        end
    end
end

-- Remove the tracer line for a player
local function RemoveTracer(player)
    if Tracers[player] then
        Tracers[player]:Destroy()
        Tracers[player] = nil
    end
end


-- Check if the player is on the same team or an enemy team
local function IsEnemyTeam(player)
    local playerTeam = player.Team
    local localPlayerTeam = Player.Team

    return playerTeam ~= localPlayerTeam
end

-- Aimbot feature: Find closest enemy and lock onto the middle of their ESP box (with 45° FOV)
local function LockOntoClosestEnemy()
    local closestPlayer = nil
    local closestDistance = math.huge
    local myCharacter = Player.Character
    local mouse = Player:GetMouse()

    if not myCharacter then return end

    -- Get the player's camera and view
    local camera = game:GetService("Workspace").CurrentCamera
    local cameraCFrame = camera.CFrame
    local cameraPosition = cameraCFrame.Position
    local cameraLookVector = cameraCFrame.LookVector  -- The direction the camera is facing

    -- Loop through all players
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= Player and IsEnemyTeam(player) and player.Character then
            local character = player.Character
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                -- Get the center position of the player's ESP box (BillboardGui)
                local billboardGui = HighlightedParts[player] and HighlightedParts[player][1]  -- The first box for the player
                if billboardGui then
                    local targetPosition = billboardGui.Adornee.Position + Vector3.new(0, 2, 0)  -- Center of the ESP box (adjusted above the torso)

                    -- Calculate the direction vector from the player's camera to the enemy's target position
                    local directionToTarget = (targetPosition - cameraPosition).unit
                    local angle = math.acos(cameraLookVector:Dot(directionToTarget)) * (180 / math.pi)  -- Angle in degrees

                    -- Check if the enemy is within a 45° FOV
                    if angle <= 45 then
                        -- Calculate the distance from the player to the target position
                        local distance = (myCharacter.HumanoidRootPart.Position - targetPosition).Magnitude
                        if distance < closestDistance then
                            closestDistance = distance
                            closestPlayer = player
                        end
                    end
                end
            end
        end
    end

    -- Lock the aim to the closest enemy only if right-click is held down
    if closestPlayer and game:GetService("UserInputService"):IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
        local targetCharacter = closestPlayer.Character
        local targetHumanoidRootPart = targetCharacter and targetCharacter:FindFirstChild("HumanoidRootPart")

        if targetHumanoidRootPart then
            -- Smoothly rotate the camera to face the target (without moving the player)
            local targetPosition = targetHumanoidRootPart.Position
            local lookAt = CFrame.new(myCharacter.HumanoidRootPart.Position, targetPosition)
            game:GetService("Workspace").CurrentCamera.CFrame = CFrame.new(cameraPosition, targetPosition)  -- Rotate camera to face the target
        end
    end
end

local function LockOntoClosestEnemy()
    local closestPlayer = nil
    local closestDistance = math.huge
    local myCharacter = Player.Character
    local mouse = Player:GetMouse()

    if not myCharacter then return end

    -- Get the player's camera and view
    local camera = game:GetService("Workspace").CurrentCamera
    local cameraCFrame = camera.CFrame
    local cameraPosition = cameraCFrame.Position
    local cameraLookVector = cameraCFrame.LookVector  -- The direction the camera is facing

    -- Get mouse position
    local mousePos = game:GetService("UserInputService"):GetMouseLocation()

    -- Get the radius and position of the FOV circle
    local fovRadius = _G.CircleRadius
    local fovCenter = Vector2.new(mousePos.X, mousePos.Y)

    -- Loop through all players
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= Player and IsEnemyTeam(player) and player.Character then
            local character = player.Character
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                -- Get the center position of the player's ESP box (BillboardGui)
                local billboardGui = HighlightedParts[player] and HighlightedParts[player][1]  -- The first box for the player
                if billboardGui then
                    local targetPosition = billboardGui.Adornee.Position + Vector3.new(0, 2, 0)  -- Center of the ESP box (adjusted above the torso)

                    -- Calculate the direction vector from the player's camera to the enemy's target position
                    local directionToTarget = (targetPosition - cameraPosition).unit
                    local angle = math.acos(cameraLookVector:Dot(directionToTarget)) * (180 / math.pi)  -- Angle in degrees

                    -- Check if the enemy is within a 45° FOV
                    if angle <= 45 then
                        -- Calculate the distance from the player to the target position
                        local distance = (myCharacter.HumanoidRootPart.Position - targetPosition).Magnitude
                        if distance < closestDistance then
                            -- Check if the target is within the FOV circle (using mouse position and distance from the FOV center)
                            local screenPosition = camera:WorldToScreenPoint(targetPosition)
                            local screenVector = Vector2.new(screenPosition.X, screenPosition.Y)
                            local distanceFromFovCenter = (screenVector - fovCenter).Magnitude
                            
                            -- If the player is within the FOV circle (distance is less than the circle radius)
                            if distanceFromFovCenter <= fovRadius then
                                closestDistance = distance
                                closestPlayer = player
                            end
                        end
                    end
                end
            end
        end
    end

    -- Lock the aim to the closest enemy only if right-click is held down
    if closestPlayer and game:GetService("UserInputService"):IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
        local targetCharacter = closestPlayer.Character
        local targetHumanoidRootPart = targetCharacter and targetCharacter:FindFirstChild("HumanoidRootPart")

        if targetHumanoidRootPart then
            -- Smoothly rotate the camera to face the target (without moving the player)
            local targetPosition = targetHumanoidRootPart.Position
            local lookAt = CFrame.new(myCharacter.HumanoidRootPart.Position, targetPosition)
            game:GetService("Workspace").CurrentCamera.CFrame = CFrame.new(cameraPosition, targetPosition)  -- Rotate camera to face the target
        end
    end
end

local Toggle = MainTab:CreateToggle({
    Name = "ESP",
    CurrentValue = false,
    Flag = "Toggle1",
    Callback = function(Value)
        ESPEnabled = Value

        for _, player in pairs(game.Players:GetPlayers()) do
            if player.Character and player.Character:FindFirstChild("UpperTorso") and IsEnemyTeam(player) then
                if ESPEnabled then
                    CreateOutline(player)
                    if ESPTracerEnabled then -- Only create tracer if the tracer toggle is on
                        CreateTracer(player)
                    end
                else
                    UnhighlightPlayer(player)
                    RemoveTracer(player)
                end
            end
        end
    end,
})

local Dropdown = MainTab:CreateDropdown({
    Name = "Esp Color",
    Options = {"Default (red)","Purple", "Blue", "Green", "Yellow"},
    CurrentOption = {"Option 1"},
    MultipleOptions = false,
    Flag = "Dropdown1",
    Callback = function(Options)
        local selectedColor = Options[1]

        if selectedColor == "Default (red)" then
            CurrentESPColor = Color3.fromRGB(139, 0, 0)
        elseif selectedColor == "Purple" then
            CurrentESPColor = Color3.fromRGB(128, 0, 128)
        elseif selectedColor == "Blue" then
            CurrentESPColor = Color3.fromRGB(0, 0, 255)
        elseif selectedColor == "Green" then
            CurrentESPColor = Color3.fromRGB(0, 255, 0)
        elseif selectedColor == "Yellow" then
            CurrentESPColor = Color3.fromRGB(255, 255, 0)
        end

        if ESPEnabled then
            for _, player in pairs(game.Players:GetPlayers()) do
                if player.Character and player.Character:FindFirstChild("UpperTorso") and IsEnemyTeam(player) then
                    UnhighlightPlayer(player)
                    CreateOutline(player)
                end
            end
        end
    end,
})

-- Initialize ESP and Tracers for players already in the game
game.Players.PlayerAdded:Connect(function(player)
    if player ~= Player and IsEnemyTeam(player) and ESPEnabled and player.Character and player.Character:FindFirstChild("UpperTorso") then
        CreateOutline(player)
        if ESPTracerEnabled then
            CreateTracer(player)
        end
    end
end)

for _, player in pairs(game.Players:GetPlayers()) do
    if player ~= Player and IsEnemyTeam(player) and ESPEnabled and player.Character and player.Character:FindFirstChild("UpperTorso") then
        CreateOutline(player)
        if ESPTracerEnabled then
            CreateTracer(player)
        end
    end
end

-- ESP Tracer Toggle
local TracerToggle = MainTab:CreateToggle({
    Name = "ESP Tracers",
    CurrentValue = false,
    Flag = "TracerToggle",
    Callback = function(Value)
        ESPTracerEnabled = Value
        if ESPEnabled then -- Update tracers only if ESP is also enabled
            for _, player in pairs(game.Players:GetPlayers()) do
                if player.Character and player.Character:FindFirstChild("UpperTorso") and IsEnemyTeam(player) then
                    RemoveTracer(player) -- Remove old tracers
                    if ESPTracerEnabled then
                        CreateTracer(player) -- Add new tracers if enabled
                    end
                end
            end
        end
    end,
})


-- Toggle Aimbot on/off
local ToggleAimbot = MainTab:CreateToggle({
    Name = "Aimbot",
    CurrentValue = false,
    Flag = "Toggle3", -- A flag is the identifier for the configuration file
    Callback = function(Value)
        -- Continuously run the aimbot logic when toggled on
        if Value then
            game:GetService("RunService").Heartbeat:Connect(function()
                if game:GetService("UserInputService"):IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
                    LockOntoClosestEnemy()  -- Run the aimbot logic while right-click is held down
                end
            end)
        end
    end,
})

-- Monitor new player joins and updates
game.Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function()
        -- Reset ESP for new player joining
        if ESPEnabled and IsEnemyTeam(player) then
            CreateOutline(player)
            if ESPTracerEnabled then
                CreateTracer(player)
            end
        end
    end)

    -- Monitor team changes
    player.Changed:Connect(function(property)
        if property == "Team" then
            if ESPEnabled then
                if IsEnemyTeam(player) then
                    CreateOutline(player)
                    if ESPTracerEnabled then
                        CreateTracer(player)
                    end
                else
                    UnhighlightPlayer(player)
                    RemoveTracer(player)
                end
            end
        end
    end)
end)

-- Ensure ESP is removed when players leave
game.Players.PlayerRemoving:Connect(function(player)
    UnhighlightPlayer(player)
    RemoveTracer(player)
end)

local Toggle = MainTab:CreateToggle({
    Name = "Aimbot Fov",
    CurrentValue = false,
    Flag = "Toggle1", -- Flag for configuration saving
    Callback = function(Value)
        -- Set up global settings for the circle
        _G.CircleSides = 64
        _G.CircleColor = Color3.fromRGB(255, 255, 255)
        _G.CircleTransparency = 0.7
        _G.CircleRadius = 80
        _G.CircleFilled = false
        _G.CircleVisible = Value  -- Toggle visibility based on the toggle value
        _G.CircleThickness = 0

        -- Check if the circle should be visible or not
        if _G.CircleVisible then
            -- Create or update the circle drawing
            if not _G.Circle then
                _G.Circle = Drawing.new("Circle")
                _G.Circle.Filled = _G.CircleFilled
                _G.Circle.Thickness = _G.CircleThickness
                _G.Circle.Radius = _G.CircleRadius
                _G.Circle.NumSides = _G.CircleSides
                _G.Circle.Color = _G.CircleColor
                _G.Circle.Transparency = _G.CircleTransparency
            end
        else
            -- Remove the circle if it's not visible
            if _G.Circle then
                _G.Circle.Visible = false
            end
        end
    end,
})

-- Update the circle's position if it exists
game:GetService("RunService").RenderStepped:Connect(function()
    if _G.Circle and _G.CircleVisible then
        local player = game.Players.LocalPlayer
        local mousePos = game:GetService("UserInputService"):GetMouseLocation()
        
        -- Set the circle's position based on the mouse location or the player's character
        _G.Circle.Position = Vector2.new(mousePos.X, mousePos.Y)
    end
end)

local Toggle = MainTab:CreateToggle({
    Name = "No Spread",
    CurrentValue = false,  -- This is the default value when the toggle is off
    Flag = "Toggle5", -- Unique flag for saving the setting
    Callback = function(Value)
        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()  -- Ensure the character is loaded
        local tool = character and character:FindFirstChildOfClass("Tool")

        if tool and tool:FindFirstChild("Handle") then
            -- Check if the gun has a 'BulletSpread' or a similar mechanism for spread
            local gun = tool

            -- Some guns might have the BulletSpread value, but not all.
            -- We're going to assume we're controlling spread by modifying a different method or property.
            
            -- Assuming the spread is controlled via a value or property (this can vary based on Arsenal updates)
            -- Replace the `BulletSpread` logic with the actual method to disable spread, if applicable.
            if Value then
                -- Disable spread by setting the property or using a function to handle no spread
                if gun:FindFirstChild("BulletSpread") then
                    gun.BulletSpread.Value = 0  -- Set BulletSpread to 0 to disable spread
                end
            else
                -- Restore normal spread (assuming it was 1 by default)
                if gun:FindFirstChild("BulletSpread") then
                    gun.BulletSpread.Value = 1  -- Restore default spread value
                end
            end
        end
    end,
})

 -- END OF MAIN TAB --

 -- MISCELLANEOUS TAB --
 local MiscellaneousTab = Window:CreateTab("Miscellaneous", nil) -- Title, Image

-- This script assumes you have a working 'MiscellaneousTab' and 'OpTab' setup

local player = game.Players.LocalPlayer

-- Make sure we wait for the player's character to load, including the Humanoid
local function GetHumanoid()
    local character = player.Character or player.CharacterAdded:Wait()
    return character:WaitForChild("Humanoid")
end

-- Create a slider for WalkSpeed in the MiscellaneousTab
local Slider = MiscellaneousTab:CreateSlider({
    Name = "WalkSpeed",
    Range = {1, 100},
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = 10,
    Flag = "Slider1",  -- A flag for configuration saving
    Callback = function(Value)
        -- Get the player's character
        local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
        
        -- Ensure the character has been fully loaded
        if character and character:FindFirstChild("Humanoid") then
            local humanoid = character:FindFirstChild("Humanoid")
            humanoid.WalkSpeed = Value  -- Set the WalkSpeed to the value selected by the slider
        end
    end,
})

 local Input = MiscellaneousTab:CreateInput({
    Name = "Tp Via Name",
    CurrentValue = "",
    PlaceholderText = "Tp Via Name",
    RemoveTextAfterFocusLost = false,
    Flag = "Input1",
    Callback = function(Text)
        -- This is where the teleportation logic will be added

        local Players = game:GetService("Players")
        
        local function teleportToPlayer(playerNameOrDisplayName)
            local targetPlayer = nil

            -- First, try to find by display name
            for _, player in pairs(Players:GetPlayers()) do
                if player.DisplayName:lower() == playerNameOrDisplayName:lower() or player.Name:lower() == playerNameOrDisplayName:lower() then
                    targetPlayer = player
                    break
                end
            end

            if targetPlayer then
                local targetCharacter = targetPlayer.Character
                if targetCharacter then
                    local targetHumanoidRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")
                    if targetHumanoidRootPart then
                        local playerCharacter = Players.LocalPlayer.Character
                        if playerCharacter then
                            local playerHumanoidRootPart = playerCharacter:FindFirstChild("HumanoidRootPart")
                            if playerHumanoidRootPart then
                                -- Add a delay to avoid instant teleportation
                                wait(math.random(0.5, 1))

                                -- Teleport the player to a position slightly above the target player
                                playerHumanoidRootPart.CFrame = targetHumanoidRootPart.CFrame * CFrame.new(0, 5, 0)
                            end
                        end
                    end
                end
            else
                -- If no player was found, print an error message
                warn("Player not found with that name or display name")
            end
        end

        -- Check if the input text is not empty and then teleport
        if Text ~= "" then
            teleportToPlayer(Text)
        end
    end,
})

local Button = MiscellaneousTab:CreateButton({
    Name = "Self Golden Knife",
    Callback = function()
        -- Check if the player should get a golden knife
        if someCondition then  -- You can replace "someCondition" with your actual condition
            debug.setconstant(clientEnv.givetools, 30, "Golden Knife")
        else
            debug.setconstant(clientEnv.givetools, 30, "Knife")
        end
        
        -- Give the player the tool
        clientEnv.givetools()
        
        -- Use the weapon
        require(game.Players.LocalPlayer.PlayerGui.GUI.Client.Functions.Weapons).usethatgun()
    end
})

-- TEXT TAB --
local TextTab = Window:CreateTab("Text", nil) -- Title, Image

local Input = TextTab:CreateInput({
    Name = "Chat bypass",
    CurrentValue = "",
    PlaceholderText = "Chat bypass",
    RemoveTextAfterFocusLost = false,
    Flag = "Input1",
    Callback = function(Text)
        -- Convert the input text to the desired format
        local function formatText(inputText)
            local formattedText = ""
            for i = 1, #inputText do
                local char = inputText:sub(i, i)
                formattedText = formattedText .. "<" .. char:lower() .. ">"
            end
            return formattedText
        end

        -- Listen for when the user presses "Enter" in the input box
        local function onEnterKey(input)
            if input.KeyCode == Enum.KeyCode.Return then
                local formattedMessage = formatText(Text)
                
                -- Send the formatted message to the chat using ChatService
                game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(formattedMessage, "All")
            end
        end

        -- Connect the Enter key press to the callback
        game:GetService("UserInputService").InputBegan:Connect(onEnterKey)
    end,
}) 


-- END OF TEXT TAB --
local OpTab = Window:CreateTab("OP (broken)", nil) -- Title, Image

-- OP Tab --

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

-- Create a dummy gun (for simulating shooting)
local gun = Instance.new("Tool")
gun.Name = "Gun"
gun.RequiresHandle = true
gun.Parent = player.Backpack

-- Function to check if a player is alive
local function IsPlayerAlive(player)
    return player and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0
end

-- Simulate shooting (deals damage)
local function ShootAtTarget(target)
    if target and target.Character and target.Character:FindFirstChild("Humanoid") then
        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Exclude
        raycastParams.FilterDescendantsInstances = {character}

        local rayOrigin = character.HumanoidRootPart.Position
        local rayDirection = (target.Character.HumanoidRootPart.Position - rayOrigin).unit * 500

        local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)

        if raycastResult and raycastResult.Instance and raycastResult.Instance.Parent and raycastResult.Instance.Parent:FindFirstChild("Humanoid") then
            local hitHumanoid = raycastResult.Instance.Parent:FindFirstChild("Humanoid")
            if hitHumanoid and hitHumanoid ~= humanoid then
                hitHumanoid:TakeDamage(100)  -- Adjust damage as needed
            end
        end
    end
end

-- Get the nearest *alive* player
local function GetNextTarget(currentPlayer)
    local nextTarget = nil
    local shortestDistance = math.huge

    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer ~= currentPlayer and IsPlayerAlive(otherPlayer) then -- Exclude self and current target
            local otherCharacter = otherPlayer.Character
            if otherCharacter and otherCharacter:FindFirstChild("HumanoidRootPart") then
                local distance = (character.HumanoidRootPart.Position - otherCharacter.HumanoidRootPart.Position).Magnitude
                if distance < shortestDistance then
                    shortestDistance = distance
                    nextTarget = otherPlayer
                end
            end
        end
    end
    return nextTarget
end

-- Killing and teleporting function
local function KillAndTeleport()
    local currentTarget = nil -- Keep track of the current target

    while killing do
        currentTarget = GetNextTarget(currentTarget) -- Find the next target, excluding the current one.

        if currentTarget and IsPlayerAlive(currentTarget) then
            local targetPosition = currentTarget.Character.HumanoidRootPart.Position
            if character and character:FindFirstChild("HumanoidRootPart") then
                character:SetPrimaryPartCFrame(CFrame.new(targetPosition))
            end

            wait(0.1) -- Small delay after teleport

            ShootAtTarget(currentTarget)

            -- Check if the target is still alive after the shot. If not, get the next target immediately.
            if not IsPlayerAlive(currentTarget) then
                currentTarget = nil -- Reset current target to find the next one
            end
        else
            wait(0.1) -- If no target is found, wait briefly before checking again.
        end
    end
end

-- Killing sequence toggle
local killing = false

local function StartKillingSequence()
    if killing then return end
    killing = true
    KillAndTeleport() -- Start the kill/teleport loop
end

local function StopKillingSequence()
    killing = false
end

-- Assuming OpTab is properly defined, toggle the sequence
local Toggle = OpTab:CreateToggle({
    Name = "Kill Everyone",
    CurrentValue = false,
    Flag = "Toggle1",
    Callback = function(Value)
        if Value then
            StartKillingSequence()
        else
            StopKillingSequence()
        end
    end,
})

local OtherGamesTab = Window:CreateTab("OtherGames", nil) -- Title, Image

local SecondWindow = Rayfield:CreateWindow({
    Name = "Spelling Bee",
    Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
    LoadingTitle = "KrustyKrabHub",
    LoadingSubtitle = "By Mrkrabz",
    Theme = "Ocean", -- Check https://docs.sirius.menu/rayfield/configuration/themes
 
    DisableRayfieldPrompts = false,
    DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface
 
    ConfigurationSaving = {
       Enabled = true,
       FolderName = nil, -- Create a custom folder for your hub/game
       FileName = "Big Hub"
    },
 
    Discord = {
       Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
       Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
       RememberJoins = true -- Set this to false to make them join the discord every time they load it up
    },
 
    KeySystem = false, -- Set this to true to use our key system
    KeySettings = {
       Title = "Untitled",
       Subtitle = "Key System",
       Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
       FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
       SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
       GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
       Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
    }
 })

         local SpellingbeeTab = SecondWindow:CreateTab("Spelling Bee", nil) -- Title, Image

         local wordlist = {
            ["rbxassetid://119699946181489"] = "dolphin",
            ["rbxassetid://17620333788"] = "thesis",
            ["rbxassetid://18257417645"] = "refrain",
            ["rbxassetid://17620149976"] = "comply",
            ["rbxassetid://17627837193"] = "robust",
            ["rbxassetid://17632835647"] = "burial",
            ["rbxassetid://17632805150"] = "monk",
            ["rbxassetid://17620204375"] = "random",
            ["rbxassetid://18257146758"] = "pigeon",
            ["rbxassetid://17620183873"] = "margin",
            ["rbxassetid://17704895495"] = "transaction",
            ["rbxassetid://135308613056609"] = "villain",
            ["rbxassetid://102456753847783"] = "human",
            ["rbxassetid://77466979227881"] = "echo",
            ["rbxassetid://18263817395"] = "suck",
            ["rbxassetid://80738513122758"] = "absorb",
            ["rbxassetid://17620365116"] = "workout",
            ["rbxassetid://17627896746"] = "voluntary",
            ["rbxassetid://17632830629"] = "automatic",
            ["rbxassetid://18263903610"] = "alphabet",
            ["rbxassetid://18263893180"] = "password",
            ["rbxassetid://73040937432058"] = "immobilise",
            ["rbxassetid://107611408395063"] = "quill",
            ["rbxassetid://133882847828955"] = "uncomfortable",
            ["rbxassetid://17704908669"] = "validity",
            ["rbxassetid://90727890439436"] = "photographer",
            ["rbxassetid://138150769315459"] = "translucent",
            ["rbxassetid://126203841438523"] = "rhythm",
            ["rbxassetid://17707360297"] = "practitioner",
            ["rbxassetid://18257137133"] = "duck",
            ["rbxassetid://17704818087"] = "trauma",
            ["rbxassetid://119025155438467"] = "familiar",
            ["rbxassetid://17620325241"] = "pursuit",
            ["rbxassetid://17627829602"] = "sigh",
            ["rbxassetid://18263962173"] = "gender",
            ["rbxassetid://17620519693"] = "exile",
            ["rbxassetid://99874477789348"] = "pray",
            ["rbxassetid://17627808861"] = "vein",
            ["rbxassetid://97192746411344"] = "concentration",
            ["rbxassetid://18257268915"] = "abstract",
            ["rbxassetid://101791465848329"] = "hungry",
            ["rbxassetid://17632862191"] = "debris",
            ["rbxassetid://140417801525692"] = "semicircle",
            ["rbxassetid://86409026377667"] = "excellent",
            ["rbxassetid://85723587162167"] = "transportation",
            ["rbxassetid://18263755358"] = "melancholy",
            ["rbxassetid://106985843863114"] = "adolescent",
            ["rbxassetid://18257408753"] = "nonplussed",
            ["rbxassetid://75575501402787"] = "aspiration",
            ["rbxassetid://17704873644"] = "parallel",
            ["rbxassetid://98510562083918"] = "ink",
            ["rbxassetid://108828500723259"] = "agnostic",
            ["rbxassetid://18263987667"] = "flavour",
            ["rbxassetid://88497803472729"] = "formidable",
            ["rbxassetid://131174690191810"] = "abolish",
            ["rbxassetid://84228988235837"] = "betray",
            ["rbxassetid://17704903466"] = "scholarship",
            ["rbxassetid://116481385444935"] = "reliability",
            ["rbxassetid://17620602249"] = "albeit",
            ["rbxassetid://98225180005851"] = "meditate",
            ["rbxassetid://108734885770838"] = "state",
            ["rbxassetid://17705033632"] = "magnificent",
            ["rbxassetid://18264025587"] = "chronic",
            ["rbxassetid://17707340325"] = "firefighter",
            ["rbxassetid://17713083658"] = "consumption",
            ["rbxassetid://17620700276"] = "asthma",
            ["rbxassetid://70645856927149"] = "necromancer",
            ["rbxassetid://17705282482"] = "controversial",
            ["rbxassetid://71087464810297"] = "lightning",
            ["rbxassetid://18257253087"] = "accomplishment",
            ["rbxassetid://17713017966"] = "discombobulate",
            ["rbxassetid://17705254483"] = "correspondence",
            ["rbxassetid://83560684718752"] = "hypermetropia",
            ["rbxassetid://82887742240951"] = "forbid",
            ["rbxassetid://70867787098828"] = "burger",
            ["rbxassetid://17704808351"] = "await",
            ["rbxassetid://73124320355251"] = "anatomical",
            ["rbxassetid://17704822386"] = "vague",
            ["rbxassetid://17632856701"] = "curious",
            ["rbxassetid://17627920277"] = "gastronomic",
            ["rbxassetid://99199820973488"] = "zygote",
            ["rbxassetid://122475465397699"] = "furious",
            ["rbxassetid://116018579968737"] = "ricochet",
            ["rbxassetid://18263796834"] = "participation",
            ["rbxassetid://17620609623"] = "accommodate",
            ["rbxassetid://120578183641103"] = "deleterious",
            ["rbxassetid://17713030113"] = "sentimental",
            ["rbxassetid://17627869431"] = "convey",
            ["rbxassetid://74143004708139"] = "noble",
            ["rbxassetid://17705210045"] = "integrity",
            ["rbxassetid://97227188440853"] = "circle",
            ["rbxassetid://120763790488963"] = "broccoli",
            ["rbxassetid://17713098718"] = "diplomatic",
            ["rbxassetid://17704887854"] = "revelation",
            ["rbxassetid://17707289545"] = "tremendous",
            ["rbxassetid://17628083241"] = "wednesday",
            ["rbxassetid://94790688626425"] = "solidarity",
            ["rbxassetid://18263703239"] = "counterintuitive",
            ["rbxassetid://17704857752"] = "simultaneous",
            ["rbxassetid://18257534795"] = "exponential",
            ["rbxassetid://138704636737437"] = "alliance",
            ["rbxassetid://116383900625275"] = "strategic",
            ["rbxassetid://114962550365383"] = "diesel",
            ["rbxassetid://17705151730"] = "offender",
            ["rbxassetid://17620534977"] = "expenditure",
            ["rbxassetid://86969237568134"] = "paradox",
            ["rbxassetid://18257495713"] = "abscond",
            ["rbxassetid://123500259853820"] = "stereotype",
            ["rbxassetid://18257209590"] = "transparency",
            ["rbxassetid://134166567634467"] = "probably",
            ["rbxassetid://85743131773074"] = "tangerine",
            ["rbxassetid://18257220047"] = "seldom",
            ["rbxassetid://126503711288758"] = "shareholder",
            ["rbxassetid://123035811233574"] = "thesaurus",
            ["rbxassetid://18263831025"] = "spokesperson",
            ["rbxassetid://17620374296"] = "worthwhile",
            ["rbxassetid://17627821778"] = "colonel",
            ["rbxassetid://17620542202"] = "endeavour",
            ["rbxassetid://72332633000965"] = "beneficiary",
            ["rbxassetid://17705270738"] = "attorney",
            ["rbxassetid://17707321238"] = "refugee",
            ["rbxassetid://106144085367658"] = "congratulate",
            ["rbxassetid://17620226078"] = "remarkable",
            ["rbxassetid://125209787139773"] = "portfolio",
            ["rbxassetid://82419708734232"] = "doctrine",
            ["rbxassetid://18264002127"] = "elaborate",
            ["rbxassetid://79171344178056"] = "abhorrent",
            ["rbxassetid://18257529285"] = "frolic",
            ["rbxassetid://18257481978"] = "malapropism",
            ["rbxassetid://17619435492"] = "assumption",
            ["rbxassetid://121128593595148"] = "opaque",
            ["rbxassetid://83734163825187"] = "municipal",
            ["rbxassetid://17627767018"] = "surveillance",
            ["rbxassetid://137651872335785"] = "anaphylactic",
            ["rbxassetid://99614655778679"] = "limousine",
            ["rbxassetid://140119942342374"] = "fictitious",
            ["rbxassetid://99148958188453"] = "misconception",
            ["rbxassetid://18263942591"] = "ideological",
            ["rbxassetid://81056535030917"] = "pomegranate",
            ["rbxassetid://91401812744248"] = "rye",
            ["rbxassetid://18263643124"] = "optimism",
            ["rbxassetid://17705244259"] = "residential",
            ["rbxassetid://18257182776"] = "warrior",
            ["rbxassetid://109783304461923"] = "cuisine",
            ["rbxassetid://88206521550650"] = "sapphire",
            ["rbxassetid://17620710842"] = "phlegm",
            ["rbxassetid://17628071882"] = "handkerchief",
            ["rbxassetid://18257398103"] = "dilate",
            ["rbxassetid://98428059169323"] = "liable",
            ["rbxassetid://18264037984"] = "pronunciation",
            ["rbxassetid://17707373034"] = "neighbouring",
            ["rbxassetid://81096857844980"] = "intermediate",
            ["rbxassetid://70449437840011"] = "susceptible",
            ["rbxassetid://17704831171"] = "technological",
            ["rbxassetid://17707350399"] = "exaggerate",
            ["rbxassetid://125963298456666"] = "coalescence",
            ["rbxassetid://18257335313"] = "monosyllabic",
            ["rbxassetid://18263845478"] = "passionate",
            ["rbxassetid://18257462686"] = "captious",
            ["rbxassetid://80335572225978"] = "neuroplasticity",
            ["rbxassetid://121960186073109"] = "pestilence",
            ["rbxassetid://17627928668"] = "obesity",
            ["rbxassetid://18263975679"] = "embassy",
            ["rbxassetid://18257432800"] = "oblivious",
            ["rbxassetid://17707300132"] = "significance",
            ["rbxassetid://92147310918517"] = "ravenous",
            ["rbxassetid://71717044292435"] = "personnel",
            ["rbxassetid://111287681130849"] = "guideline",
            ["rbxassetid://17627904367"] = "subsidy",
            ["rbxassetid://94765859644521"] = "imprisonment",
            ["rbxassetid://18257344093"] = "cacophony",
            ["rbxassetid://115799550003376"] = "telepathy",
            ["rbxassetid://71445957374329"] = "dauntless",
            ["rbxassetid://112855395997904"] = "ambiguous",
            ["rbxassetid://18257310148"] = "brusque",
            ["rbxassetid://17713076703"] = "vulnerability",
            ["rbxassetid://122762077142796"] = "ubiquitous",
            ["rbxassetid://17632817018"] = "appetite",
            ["rbxassetid://18257204844"] = "scrutiny",
            ["rbxassetid://103384123284811"] = "erratic",
            ["rbxassetid://18257163705"] = "legendary",
            ["rbxassetid://90620950582221"] = "hypothesis",
            ["rbxassetid://71410655886078"] = "recipient",
            ["rbxassetid://89954467034919"] = "psychological",
            ["rbxassetid://122343089169402"] = "subterranean",
            ["rbxassetid://122827915740003"] = "obituary",
            ["rbxassetid://17707384399"] = "negotiation",
            ["rbxassetid://89675342289919"] = "pygmy",
            ["rbxassetid://18257367013"] = "nauseous",
            ["rbxassetid://108024036194672"] = "myopic",
            ["rbxassetid://113818213569377"] = "monochromatic",
            ["rbxassetid://18257170998"] = "predecessor",
            ["rbxassetid://89113407015417"] = "silhouette",
            ["rbxassetid://18257293601"] = "aggrandize",
            ["rbxassetid://79379278211018"] = "kaleidoscope",
            ["rbxassetid://17707307947"] = "rehabilitation",
            ["rbxassetid://82966257065332"] = "gentrification",
            ["rbxassetid://17707273461"] = "sovereignty",
            ["rbxassetid://90499060394972"] = "reminiscence",
            ["rbxassetid://115598216153845"] = "bourgeoisie",
            ["rbxassetid://81085227021194"] = "aegis",
            ["rbxassetid://17713056403"] = "hierarchy",
            ["rbxassetid://18257542135"] = "iconoclast",
            ["rbxassetid://109297423141020"] = "sequoia",
            ["rbxassetid://70473378112394"] = "gubernatorial",
            ["rbxassetid://72672639356799"] = "subpoena",
            ["rbxassetid://18257618490"] = "abacaxi",
            ["rbxassetid://129862611252162"] = "thalassophobia",
            ["rbxassetid://17628020594"] = "fuchsia",
            ["rbxassetid://18257380431"] = "anachronistic",
            ["rbxassetid://114067140591080"] = "paroxysm",
            ["rbxassetid://18257356413"] = "paraphernalia",
            ["rbxassetid://124258616891836"] = "lepidopterology",
            ["rbxassetid://18257506847"] = "languid",
            ["rbxassetid://17632825637"] = "bureaucracy",
            ["rbxassetid://17627999828"] = "acquiesce",
            ["rbxassetid://124529745822252"] = "capricious",
            ["rbxassetid://85585767847749"] = "hieroglyphics",
            ["rbxassetid://112842520789035"] = "sesquipedalian",
            ["rbxassetid://17632791064"] = "incomprehensibility",
            ["rbxassetid://111879126889878"] = "soliloquy",
            ["rbxassetid://93261780878211"] = "onomatopoeia",
            ["rbxassetid://95957616756447"] = "entrepreneur",
            ["rbxassetid://17620759598"] = "paradigm",
            ["rbxassetid://124212548906430"] = "independence",
            ["rbxassetid://95282167666552"] = "procrastinate",
            ["rbxassetid://102185883621465"] = "rendezvous",
            ["rbxassetid://82352623119207"] = "glockenspiel",
            ["rbxassetid://17627975911"] = "syllepsis",
            ["rbxassetid://86033706945371"] = "liaison",
            ["rbxassetid://17620345413"] = "antidisestablishmentarianism",
            ["rbxassetid://112058503215092"] = "problematic",
            ["rbxassetid://92215948292569"] = "sequacious",
            ["rbxassetid://17628064988"] = "ingenious",
            ["rbxassetid://18257389997"] = "anemone",
            ["rbxassetid://71678595652129"] = "heritage",
            ["rbxassetid://17620505761"] = "humanitarian",
            ["rbxassetid://18257323258"] = "caustic",
            ["rbxassetid://72942600245342"] = "aerodynamic",
            ["rbxassetid://120786669970568"] = "venerate",
            ["rbxassetid://98239573833470"] = "pharaoh",
            ["rbxassetid://107315012360412"] = "polydactyly",
            ["rbxassetid://17620589321"] = "narcissistic",
            ["rbxassetid://93365154213072"] = "forthcoming",
            ["rbxassetid://17704882178"] = "separation",
            ["rbxassetid://17713066287"] = "violation",
            ["rbxassetid://18263788390"] = "notorious",
            ["rbxassetid://106543699707550"] = "pirouette",
            ["rbxassetid://72435768737741"] = "sagacious",
            ["rbxassetid://17620579985"] = "biography",
            ["rbxassetid://94700726432644"] = "eloquent",
            ["rbxassetid://17628113162"] = "minuscule",
            ["rbxassetid://17704849455"] = "prestigious",
            ["rbxassetid://18257440681"] = "supersede",
            ["rbxassetid://105732469322919"] = "reincarnation",
            ["rbxassetid://17620528227"] = "embarrassment",
            ["rbxassetid://18263664646"] = "pessimistic",
            ["rbxassetid://17627911842"] = "methodology",
            ["rbxassetid://82025751524144"] = "nutritious",
            ["rbxassetid://97611256826794"] = "pneumatic",
            ["rbxassetid://136906670235418"] = "acculturate",
            ["rbxassetid://17627937145"] = "parliamentary",
            ["rbxassetid://17707331642"] = "legislation",
            ["rbxassetid://18263742531"] = "obfuscation",
            ["rbxassetid://17705223522"] = "inhabitant",
            ["rbxassetid://105192684751247"] = "fluorescent",
            ["rbxassetid://128665658754377"] = "juxtaposition",
            ["rbxassetid://17704867480"] = "predominantly",
            ["rbxassetid://119992234251657"] = "deployment",
            ["rbxassetid://18257197694"] = "systematic",
            ["rbxassetid://17632867945"] = "commodity",
            ["rbxassetid://88356842094041"] = "supposedly",
            ["rbxassetid://139389432004640"] = "size",
            ["rbxassetid://112726533133258"] = "film",
            ["rbxassetid://113302422028204"] = "mix",
            ["rbxassetid://100067711890448"] = "pear",
            ["rbxassetid://77278723571350"] = "length",
            ["rbxassetid://115775363677306"] = "twist",
            ["rbxassetid://125555053201251"] = "filter",
            ["rbxassetid://17627875944"] = "erupt",
            ["rbxassetid://86603383226078"] = "stumble",
            ["rbxassetid://111336307566133a"] = "proof",
            ["rbxassetid://129301367618315"] = "quack",
            ["rbxassetid://106164144827690"] = "recession",
            ["rbxassetid://115907357932449"] = "syntax",
            ["rbxassetid://137931211649180"] = "exert",
            ["rbxassetid://17620089870"] = "dairy",
            ["rbxassetid://18263721867"] = "noob",
            ["rbxassetid://113296258582753"] = "hotel",
            ["rbxassetid://135518440831273"] = "clever",
            ["rbxassetid://134841673180854"] = "water",
            ["rbxassetid://116280401110349"] = "gallant",
            ["rbxassetid://73560380115539"] = "lather",
            ["rbxassetid://82235795990204"] = "oasis",
            ["rbxassetid://115567352272490"] = "town",
            ["rbxassetid://89945234291258"] = "greedy",
            ["rbxassetid://116270155445876"] = "update",
            ["rbxassetid://129568424936057"] = "pie",
            ["rbxassetid://17620726892"] = "unprecedented",
            ["rbxassetid://115301392260162"] = "mathematician",
            ["rbxassetid://127187168346802"] = "propaganda",
            ["rbxassetid://122859885984507"] = "microorganism",
            ["rbxassetid://17627757409"] = "intent",
            ["rbxassetid://17705261975"] = "breakthrough",
            ["rbxassetid://86264727885079"] = "soda",
            ["rbxassetid://131087527182954"] = "reply",
            ["rbxassetid://17620214854"] = "rally",
            ["rbxassetid://110992488713038"] = "agriculture",
            ["rbxassetid://111336307566133"] = "proof",
            ["rbxassetid://139445462509156"] = "still",
            ["rbxassetid://17632846437"] = "defy",
            ["rbxassetid://78542491010706"] = "shake",
            ["rbxassetid://127663239097832"] = "absence",
            ["rbxassetid://17627860878"] = "irony",
            ["rbxassetid://17632892861"] = "bizarre",
            ["rbxassetid://126481539910012"] = "resilience",
            ["rbxassetid://17712977280"] = "heresy",
            ["rbxassetid://80520052097207"] = "symmetrical",
            ["rbxassetid://89384242074757"] = "grub",
            ["rbxassetid://127586980434822"] = "catalogue",
            ["rbxassetid://17627887884"] = "enact",
            ["rbxassetid://70469781693470"] = "euphoria",
            ["rbxassetid://18257236422"] = "favourable",
            ["rbxassetid://18264015967"] = "accumulation",
            ["rbxassetid://86286320452222"] = "hornswoggle",
            ["rbxassetid://139833268158271"] = "surrogate", 
            ["rbxassetid://80097477282865"] = "ash",
            ["rbxassetid://91248922608173"] = "ruby",
            ["rbxassetid://132283121031638"] = "wrist",
            ["rbxassetid://82709137280034"] = "gold",
            ["rbxassetid://72368123980516"] = "giant",
            ["rbxassetid://99770067131062"] = "ionise",
            ["rbxassetid://71206756354514"] = "house",
            ["rbxassetid://102020618693697"] = "overdue",
            ["rbxassetid://73476668810120"] = "power",
            ["rbxassetid://92706054312788"] = "cliff",
            ["rbxassetid://115979653696988"] = "lactose",
            ["rbxassetid://98496714233552"] = "bayonet",
            ["rbxassetid://76232469730644"] = "bingo",
            ["rbxassetid://125087918616230"] = "cabin",
            ["rbxassetid://111702628375025"] = "prank",
            ["rbxassetid://85845746014726"] = "zephyr",
            ["rbxassetid://95183391465404"] = "intermission",
            ["rbxassetid://112305751879846"] = "bandeau",
            ["rbxassetid://114349019555811"] = "polemic",
            ["rbxassetid://136487825977974"] = "therapeutic",
            ["rbxassetid://110098752229751"] = "institutionalization",
            ["rbxassetid://126794981237325"] = "commodore",
            ["rbxassetid://103405516838095"] = "bucolic",
            ["rbxassetid://136229723152982"] = "homogeneous",
            ["rbxassetid://139823199442280"] = "utilitarianism",
            ["rbxassetid://75420795836811"] = "agoraphobic",
            ["rbxassetid://105281278011169"] = "encore",
            ["rbxassetid://94708142436657"] = "sarcophagus",
            ["rbxassetid://83854783654942"] = "extraterrestrial",
            ["rbxassetid://98015030093970"] = "puerile",
            ["rbxassetid://135155597714681"] = "verbatim",
            ["rbxassetid://86238755046399"] = "colloquialism",
            ["rbxassetid://121794379441457"] = "depilatory",
            ["rbxassetid://111965000473684"] = "uncharacteristic",
            ["rbxassetid://92411985593823"] = "rambunctious",
            ["rbxassetid://107321554203993"] = "homeopathy",
            ["rbxassetid://82464790412950"] = "verisimilitude",
            ["rbxassetid://87407947157868"] = "menagerie",
            ["rbxassetid://126270946563337"] = "phenomenon",
            ["rbxassetid://99772723640742"] = "compunction",
            ["rbxassetid://110367036610316"] = "codicil",
            ["rbxassetid://76289478501081"] = "macabre",
            ["rbxassetid://100119991534791"] = "asphyxiation",
            ["rbxassetid://112582266844124"] = "calamitous",
            ["rbxassetid://109625013162241"] = "iron",
            ["rbxassetid://99657348762334"] = "chicken",
            ["rbxassetid://110476086581191"] = "indifference",
            ["rbxassetid://103682063052182"] = "combustible",
            ["rbxassetid://121504356676507"] = "capoeira",
            ["rbxassetid://79837237305146"] = "inchoate",
            ["rbxassetid://135851462066194"] = "cyrillic",
            ["rbxassetid://118565618469497"] = "pusillanimous",
            ["rbxassetid://93977641775368"] = "apocryphal",
            ["rbxassetid://132823289980578"] = "pulchritudinous",
            ["rbxassetid://80521222355609"] = "word",
            ["rbxassetid://112635032040804"] = "unintelligible",
            ["rbxassetid://117319882689305"] = "myriad",
            ["rbxassetid://79043260418341"] = "infinitesimal",
            ["rbxassetid://95877000629418"] = "abacaxi",
            ["rbxassetid://107792347333512"] = "milieu",
            ["rbxassetid://126212796300089"] = "imminent",
            ["rbxassetid://124693070835234"] = "sapphire",
            ["rbxassetid://134394182430711"] = "champagne",
            ["rbxassetid://99128331263674"] = "proclamation",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
            ["a"] = "a",
        }

        local Label = SpellingbeeTab:CreateLabel("Current Word: None")
        local lastword = nil
        local lastsound = nil
        local typingword = false
        local autotypeenabled = true
        local pretypewait = 0.5  -- Adjust if needed
        local istypingmaybe = false  -- Adjust as needed
        
        -- Ensure this function updates the label correctly
        local function updatecurrentword(word)
            if typingword or lastword == word then return end
            lastword = word
            Label:Set("Current Word: " .. word)
            
            if autotypeenabled then
                task.delay(pretypewait, function()
                    if lastword == word and not istypingmaybe then
                        autotypeword(word)  -- Ensure this function works as expected
                    end
                end)
            end
        end
        
        -- Check sound playback and update the word based on sound ID
        local function checksound()
            local function fsic(container)
                for _, descendant in ipairs(container:GetDescendants()) do
                    -- Make sure the conditions for the sound are correct
                    if descendant:IsA("Sound") and descendant.Playing and descendant.Volume == 2.5 and descendant.PlaybackLoudness > 0 then
                        local soundId = tostring(descendant.SoundId)
                        if wordlist[soundId] and soundId ~= lastsound then
                            lastsound = soundId
                            local word = wordlist[soundId]
                            updatecurrentword(word)
                            break  -- Stop after finding the first match
                        end
                    end
                end
            end
        
            -- Check both Workspace and SoundService
            fsic(workspace)
            fsic(game:GetService("SoundService"))
        end
      
        





